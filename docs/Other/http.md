# [HTTP 复习 - 1] 从 TCP/UDP 到 DNS 解析

> Hello, HTTP.

## HTTP 的发展历程

`HTTP/0.9` 标准于 1990 年问世，因为当时的 HTTP 没有作为正式的标准被确立，该版本含有 HTTP/1.0 之前版本的意味。

`HTTP/1.0` 标准于 1996 年 5 月作为第一份标准被公布，它被记载于 [RFC1945 - Hypertext Transfer Protocol -- HTTP/1.0](http://www.ietf.org/rfc/rfc1945.txt)

`HTTP/1.1` 标准于 1999 年 6 月被公布，截止到目前它应该是最主流的 HTTP 协议版本，它被记载于 [RFC2616 - Hypertext Transfer Protocol -- HTTP/1.1](http://www.ietf.org/rfc/rfc2616.txt)

`HTTP/2` 标准于 2015 年 5 月被正式发布，它被记载于 [RFC7540 - Hypertext Transfer Protocol -- HTTP/2](http://www.ietf.org/rfc/rfc7540.txt)，它的特点是 ① 采用二进制而非明文来打包，② 多路复用，③ 修复队头堵塞，④ 允许设置设定请求优先级，⑤ 服务器推送，⑥ WebSocket 等等，后面的章节会一一详细解释。

据 [w3techs](https://w3techs.com/technologies/details/ce-http2/all/all) 统计，截止到 2019/04/22，HTTP/2 的全球占有率为 36%，普及之路任重道远啊。我的 [个人博客](https://yanceyleo.com) 在上线之初就支持了 HTTP/2。

![My Website](https://yancey-assets.oss-cn-beijing.aliyuncs.com/Jietu20190422-104131%402x.jpg)

## TCP/IP 通信传输流

在讲解 TCP/IP 通信传输流之前，首先复习一下 TCP/IP 的五层协议。

**应用层**：决定向用户提供应用服务时通信的活动。TCP/IP 协议族内预存了各类通用的应用服务。比如：FTP、DNS、HTTP 协议。

**传输层**：传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。在传输层有两个性质不同的协议，分别是 TCP (Transmission Control Protocol，传输控制协议) 和 UDP (User Data Protocol，用户数据报协议)

**网络层**：网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径到达对方计算机，并把数据包传送给对方。与对方计算机通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线。

**数据链路层**: 在物理层提供比特流服务的基础上，建立相邻结点之间的数据链路，通过差错控制提供数据帧（Frame）在信道上无差错的传输，并进行各电路上的动作系列。数据的单位称为帧（frame）

**物理层**：物理层建立在物理通信介质的基础上，作为系统和通信介质的接口，用来实现数据链路实体间透明的比特 (bit) 流传输。只有该层为真实物理通信，其它各层为虚拟通信。

TCP/IP 通信传输流如下图所示：

![Jietu20190422-142841@2x.jpg](https://yancey-assets.oss-cn-beijing.aliyuncs.com/Jietu20190422-142841%402x.jpg)

客户端在应用层 (HTTP 协议) 发出一个 HTTP 请求。

为了方便传输，在传输层 (TCP 协议) 把从应用层处收到的数据 (HTTP 请求报文) 进行分割，并在各个报文上打上标记序号及端口号后转发给网络层。

在网络层 (IP 协议)，增加作为通信目的地的 MAC 地址后转发给数据链路层。这样，发送给服务端的请求就准备齐全了。

当服务端在链路层接收到数据时，按序往上层发送，一直到应用层。**当传输到应用层时，才算真正的接收到由客户端发送过来的请求**。

## 什么是 MAC 地址？

MAC 地址 (Media Access Control Address)，直译为媒体访问控制地址，也称为局域网地址
(LAN Address)，以太网地址 (Ethernet Address) 或物理地址 (Physical Address)，它是一个用来确认网上设备位置的地址。ARP (Address Resolution Protocol) 是一种用来解析地址的协议，它可以根据 IP 地址反查出对应的 MAC 地址。

下图展示了一台电脑内网 IP 和 MAC 地址。在终端 (MAC OS 环境) 输入 `ifconfig`，找到 `en0`，便可查找本地以太网的信息。

![内网IP / MAC地址](https://yancey-assets.oss-cn-beijing.aliyuncs.com/%3AUsers%3Ayanceyleo%3ADownloads%3AJietu20190422-141257.jpg)

那么什么是 MAC 地址呢？我们知道 IP 地址是可变的，可以通过各种方式分配 IP 地址给一个设备，比如 DHCP， PPP，静态 IP 等。而 MAC 地址一般来讲却是不会变的，设备在生产时就被“烙”上了 `唯一的标识`，这个 `唯一的标识` 就是 MAC 地址。

逼乎上有个很有趣的例子：你中午在公司点了份外卖，收货地址一定是写公司的地址；晚上回到家，再点外卖时就得把地址写成家 (IP 是动态的)。但无论在哪儿点外卖，订单上的姓名和手机号一定是不变的 (MAC 地址)。

外卖小哥把午餐送到公司，但在门口等着收外卖的人肯定不止你一个 (多台设备在同一个 broadcast 网络里)，于是他就会通过姓名和手机号来精确的将午餐送到你手上。

## TCP 协议

TCP (Transmission Control Protocol, 传输控制协议) 是一种面向连接的、可靠的、基于字节流服务的传输层通信协议，由 IETF 的 RFC 793 定义。

所谓字节流服务 (Byte Stream Service) 是指为了方便传输，将大块数据分割成以报文段 (segment) 为单位的数据包进行管理。而可靠的传输服务是指 **能够把数据准确可靠的传给对方**。简言之，TCP 协议为了更容易的传送大数据而把数据分割，而且 TCP 协议可以确认数据最终是否能送达对方。

### TCP 报文

![TCP 报文](https://yancey-assets.oss-cn-beijing.aliyuncs.com/20170227111849763-0000.jpg)

**端口号**：用来标识同一台计算机的不同的应用进程。TCP 报头中的源端口号和目的端口号同 IP 数据报中的源 IP 与目的 IP 唯一确定一条 TCP 连接。

- **源端口号**：源端口和 IP 地址的作用是标识报文的返回地址。

- **目的端口号**：目的端口指明接收方计算机上的应用程序接口。

**序号**：它是当前报文段发送的数据组的第一个字节的序号。在 TCP 传送的流中，每一个字节一个序号。比如一个报文段的序号为 300，此报文段的数据部分共有 100 字节，则下一个报文段的序号为 400。**序号** 确保了 TCP 传输的有序性。

**确认号**：即 ACK(acknowledgement)，指明下一个期待收到的字节序号，表明该序号之前的所有数据已经正确无误的收到。确认号只有当 ACK 标志为 1 时才有效。比如建立连接时，SYN 报文的 ACK 标志位为 0。

**首部长度**：由于首部可能含有可选项内容，因此 TCP 报头的长度是不确定的，报头不包含任何任选字段则长度为 20 字节，4 位首部长度字段所能表示的最大值为 1111，转化为 10 进制为 15，15\*32/8 = 60，**故报头最大长度为 60 字节**。首部长度也叫数据偏移，是因为首部长度实际上指示了数据区在报文段中的起始偏移值。

**保留**：为将来定义新的用途保留，现在一般置 0。

---

| 控制位 | 说明                                                                                                                                   |
| ------ | -------------------------------------------------------------------------------------------------------------------------------------- |
| URG    | 紧急指针标志，为 1 时表示紧急指针有效，为 0 则忽略紧急指针。                                                                           |
| ACK    | 确认序号标志，为 1 时表示确认号有效，为 0 表示报文中不含确认信息，忽略确认号字段。                                                     |
| PSH    | push 标志，为 1 表示是带有 push 标志的数据，指示接收方在接收到该报文段以后，应尽快将这个报文段交给应用程序，而不是在缓冲区排队。       |
| RST    | 重置连接标志，用于重置由于主机崩溃或其他原因而出现错误的连接。或者用于拒绝非法的报文段和拒绝连接请求。                                 |
| SYN    | 同步序号，用于建立连接过程，在连接请求中，SYN=1 和 ACK=0 表示该数据段没有使用捎带的确认域，而连接应答捎带一个确认，即 SYN=1 和 ACK=1。 |
| FIN    | finish 标志，用于释放连接，为 1 时表示发送方已经没有数据发送了，即关闭本方数据流。                                                     |

**窗口**：滑动窗口大小，用来告知发送端接受端的缓存大小，以此控制发送端发送数据的速率，从而达到流量控制。窗口大小是一个 16bit 字段，因而窗口大小最大为 65535。

**校验和**：奇偶校验，此校验和是对整个的 TCP 报文段，包括 TCP 头部和 TCP 数据，以 16 位字进行计算所得。由发送端计算和存储，并由接收端进行验证。

**紧急指针**：只有当 URG 标志置 1 时紧急指针才有效。紧急指针是一个正的偏移量，和顺序号字段中的值相加表示紧急数据最后一个字节的序号。 TCP 的紧急方式是发送端向另一端发送紧急数据的一种方式。

**选项和填充**：最常见的可选字段是最长报文大小，又称为 MSS（Maximum Segment Size），每个连接方通常都在通信的第一个报文段（为建立连接而设置 SYN 标志为 1 的那个段）中指明这个选项，它表示本端所能接受的最大报文段的长度。选项长度不一定是 32 位的整数倍，所以要加填充位，即在这个字段中加入额外的零，以保证 TCP 头是 32 的整数倍。

**数据部分**：TCP 报文段中的数据部分是可选的。在一个连接建立和一个连接终止时，双方交换的报文段仅有 TCP 首部。如果一方没有数据要发送，也使用没有任何数据的首部来确认收到的数据。在处理超时的许多情况中，也会发送不带任何数据的报文段。

### TCP 建立连接 (三次握手)

- 我可以连你嘛？
- 可以。
- 那我连了。

emmmmm，单身久了，看三次握手都那么眉清目秀。

![上帝请赐给我一个女孩吧，我会好好爱她的！](https://yancey-assets.oss-cn-beijing.aliyuncs.com/images.jpeg)

TCP 协议通过三次握手 (three-way handshaking) 策略来保障将数据送达目标处。TCP 协议的特点是：**在客户端发送数据包之后会向服务端确认是否送达**。

**第一次握手**

客户端首先发送一个带 SYN (synchronize) 标志的数据包给服务端，此时为 SYN_SEND 状态。

**第二次握手**

服务端收到后，回传一个带有 SYN/ACK (acknowledgement) 的数据包以示传达确认信息，此时服务器进入 SYN_RECV 状态。

**第三次握手**

客户端收到 SYN/ACK 包后再发送一个带 ACK 标志的数据包。至此，客户端和服务器进入 established 状态，三次握手结束。连接建立后，客户端和服务端就可以进行安全可靠的数据传输了。

![三次握手](https://yancey-assets.oss-cn-beijing.aliyuncs.com/2728396534-58ee100d5822a_articlex.png)

### 为什么是三次握手？

按一般思维，我们觉得两次握手足够了，第三步看起来有些多余。那么 TCP 协议为什么要加上这一次呢？这是因为在网络请求中，我们应该时刻牢记：**网络是不可靠的，数据包是可能丢失的**。

假设没有 `第三次握手`，客户端向服务端发送一个带 SYN 标志的数据包，请求建立连接，但由于网络延迟，服务端没能及时收到这个包。上面说到如果握手过程某个阶段中断，客户端会重新发数据包。因此客户端重新发送了一个 SYN 包。

假设服务端能正常收到第二个 SYN 包，并建立了通信，一段时间后通信结束，连接被关闭。恰好第一个 SYN 包抵达了服务端，此时服务端就会发送一次 SYN/ACK 确认。

假设没有第三次确认，客户端向服务端发送了 SYN，请求建立连接。由于延迟，服务端没有及时收到这个包。于是客户端重新发送一个 SYN 包。回忆一下介绍 TCP 首部时提到的序列号，这两个包的序列号显然是相同的。
假设服务端接收到了第二个 SYN 包，建立了通信，一段时间后通信结束，连接被关闭。这时候最初被发送的 SYN 包刚刚抵达服务端，服务端又会发送一次 ACK 确认。由于两次握手就建立了连接，此时的服务端就会建立一个新的连接，然而客户端觉得自己并没有请求建立连接，所以就不会向服务端发送数据。从而导致服务端建立了一个空的连接，白白浪费资源。
在三次握手的情况下，服务端直到收到客户端的应答后才会建立连接。因此在上述情况下，客户端会接受到一个相同的 ACK 包，这时候它会抛弃这个数据包，不会和服务端进行第三次握手，因此避免了服务端建立空的连接。

### TCP 关闭连接 (四次挥手)

- 客户端：我要睡了
- 服务端：嗯，睡吧，晚安
- 服务端：我也要睡了
- 客户端：晚安，好梦

~~然后俩人各自玩手机去了。~~

**第一次挥手**

当客户端认为数据发送完成了，它将发送一个带 FIN (finish) 标志的数据包给服务端，此时进入 FIN_WAIT_1 状态。

**第二次挥手**

服务端接收到数据包后返回一个 ACK 给予确认，并进入 CLOSE_WAIT 状态，此时 A 到 B 的连接已经释放，不再接收 A 发的数据。但是因为 TCP 连接是双向的，B 仍可以发送给 A 数据。

**第三次挥手**

服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送一个 FIN 为 1 的连接释放请求，然后服务端便进入 LAST-ACK 状态。

**第四次挥手**

此时客户端给予一个 ACK 确认，服务端收到后就会将连接分配的 socket 对应的缓冲区清理掉，经过一段

A 收到释放请求后，向 B 发送确认应答，此时 A 进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有 B 的重发请求的话，就进入 CLOSED 状态。当 B 收到确认应答后，也便进入 CLOSED 状态。

![四次挥手](https://yancey-assets.oss-cn-beijing.aliyuncs.com/1604b4917affaab0.jpg)

## TCP 和 UDP 的对比

---

|              | UDP                                         | TCP                                    |
| ------------ | ------------------------------------------- | -------------------------------------- |
| 是否连接     | 无连接                                      | 面向连接                               |
| 是否可靠     | 不可靠传输，不使用流量控制和拥塞控制        | 可靠传输，使用流量控制和拥塞控制       |
| 连接对象个数 | 支持一对一，一对多，多对一和多对多交互通信  | 只能是一对一通信                       |
| 传输方式     | 面向报文                                    | 面向字节流                             |
| 首部开销     | 首部开销小，仅 8 字节                       | 首部最小 20 字节，最大 60 字节         |
| 适用场景     | 适用于实时应用（IP 电话、视频会议、直播等） | 适用于要求可靠传输的应用，例如文件传输 |

## DNS

## URI 和 URL 的区别

## 几道面试题

1. 三次握手和四次挥手详细介绍

2. TCP 有哪些手段保证可靠交付

3. DNS 解析会出错吗，为什么

## 参考

《图解 HTTP》 -- 上野宣

[TCP 和 UDP](https://juejin.im/post/583d2d6a67f356006bb7d535)

[有了 IP 地址，为什么还要用 MAC 地址？](https://www.zhihu.com/question/21546408)

[[面试 ∙ 网络] TCP/IP（四）：TCP 与 UDP 协议简介](https://juejin.im/post/5a2ff1f36fb9a04500030771)

[TCP 报文格式详解](https://blog.csdn.net/Mary19920410/article/details/58030147)

[TCP和UDP比较](https://juejin.im/post/5c6fbf54f265da2db718216a)
